package com.java.org.sort1;

import org.junit.Test;

import java.util.Arrays;

/**
 * @author zqlu
 * @date 2018-12-25
 */
public class InsertionSort {


    /**
     * 插入排序（升序）
     * 思想：
     * 插入排序借鉴：向一个有序的数组中插入一个新元素，并继续保持数据有序性的思想。
     * 也就是，将数组看成静态数据，从头到尾，一个个地插入有序数组中，并一直保证有序性。
     *
     * 要将数组分成两个区间：「已排序区间」和「未排序区间」。初始的已排序区间只有一个元素，就是数组的第一个元素。
     * 「核心思想」就是，取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间数据一直有序。
     * 重复这个过程，直到未排序区间元素为空，那么过程结束。
     */

    /**
     * 问题：
     * 1.插入排序是原地排序算法吗（空间复杂度）？
     *      插入的过程只涉及数据的移动操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
     * 2.插入排序是稳定的排序算法吗？
     *      插入排序中，只有移动才改变数据的前后顺序。为了保证插入排序算法的稳定性，
     *      当有两个元素大小相等的时候，我们不做移动，相同大小的数据在排序前后不会改变顺序，所以插入排序是稳定的排序算法。
     * 3.插入排序的时间复杂度？
     *      最好情况下，所有数据刚好是有序的，从尾到头在有序数组中，每次只需要比较一个元素就能确定位置，时间复杂度 O(n)
     *      最坏情况下，要排序的数据刚好是倒序排列的，每次插入都相当于在数组中第一个位置插入元素，需要大量的移动，时间复杂度 O(n^2)
     *      平均时间复杂度：往数据中插入一个元素的平均时间复杂度是O(n),
     *      那么对于插入排序，每次插入操作相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度就是O(n^2)
     *
     *      平均时间复杂度也可以使用逆序度。
     */


    public void sort(int[] array) {

        for (int i = 1; i < array.length; i++) { // 取「未排序区间」的元素，初始从第二个元素开始，第一个元素当作已排序区间的
            // 先提取出待插入的值
            int value = array[i];

            //下面寻找合适的位置
            int j = i - 1;
            for (; j >= 0; j--) { //在「已排序区间」找合适位置
                if (array[j] > value) {
                    // j位置的值进行后移
                    array[j+1] = array[j];
                } else {
                    break;
                }
            }

            // 将值放入合适位置
            array[j+1] = value;
        }
    }



    @Test
    public void t1() {
        InsertionSort insertionSort = new InsertionSort();
        int[] array = new int[]{3, 2, 5, 1, 7, 4};
        insertionSort.sort(array);
        System.out.println(Arrays.toString(array));
    }
}
